{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Paperkit","text":"<p>Automatically download and archive research data linked to bibliography references.</p>"},{"location":"#overview","title":"Overview","text":"<p>Civic-paperkit bridges the gap between citations and data. It reads BibTeX bibliography and automatically downloads associated datasets, supplementary materials, and research data, assisting with reproducible research and reliable data archiving.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Automatic Data Fetching - Downloads datasets from URLs or scrapes data pages</li> <li>BibTeX Integration - Works with existing <code>.bib</code> files</li> <li>Organized Storage - Files are organized by citation key</li> <li>Flexible Configuration - Simple YAML format for specifying data sources</li> <li>Checksum Verification - Optional integrity checking for downloads</li> <li>Batch Processing - Download hundreds of sources in one command</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core-modules","title":"Core Modules","text":""},{"location":"api/#configuration","title":"Configuration","text":""},{"location":"api/#civic_interconnect.paperkit.config","title":"civic_interconnect.paperkit.config","text":"<p>Configuration module for paper kit metadata handling.</p> <p>This module provides: - TypedDict definitions for asset and metadata configuration - Functions to load and normalize metadata from YAML files - Default file extension configurations for allowed assets</p> <p>File: src/civic_interconnect/paperkit/config.py</p>"},{"location":"api/#civic_interconnect.paperkit.config.DirectAssetTD","title":"DirectAssetTD","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for direct asset configuration.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>The URL of the asset.</p> <code>filename</code> <code>NotRequired[str]</code> <p>Optional filename for the asset.</p> <code>checksum</code> <code>NotRequired[str]</code> <p>Optional checksum for the asset.</p> Source code in <code>src/civic_interconnect/paperkit/config.py</code> <pre><code>class DirectAssetTD(TypedDict, total=False):\n    \"\"\"TypedDict for direct asset configuration.\n\n    Attributes\n    ----------\n    url : str\n        The URL of the asset.\n    filename : NotRequired[str]\n        Optional filename for the asset.\n    checksum : NotRequired[str]\n        Optional checksum for the asset.\n    \"\"\"\n\n    url: str\n    filename: NotRequired[str]\n    checksum: NotRequired[str]\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.config.EntryMetaTD","title":"EntryMetaTD","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for entry metadata configuration.</p> <p>Attributes:</p> Name Type Description <code>notes</code> <code>NotRequired[str]</code> <p>Optional notes about the entry.</p> <code>out_dir</code> <code>NotRequired[str]</code> <p>Optional output directory for the entry.</p> <code>assets</code> <code>NotRequired[list[AssetTD]]</code> <p>Optional list of assets associated with the entry.</p> Source code in <code>src/civic_interconnect/paperkit/config.py</code> <pre><code>class EntryMetaTD(TypedDict, total=False):\n    \"\"\"TypedDict for entry metadata configuration.\n\n    Attributes\n    ----------\n    notes : NotRequired[str]\n        Optional notes about the entry.\n    out_dir : NotRequired[str]\n        Optional output directory for the entry.\n    assets : NotRequired[list[AssetTD]]\n        Optional list of assets associated with the entry.\n    \"\"\"\n\n    notes: NotRequired[str]\n    out_dir: NotRequired[str]\n    assets: NotRequired[list[AssetTD]]\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.config.PageAssetTD","title":"PageAssetTD","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for page-based asset configuration.</p> <p>Attributes:</p> Name Type Description <code>page_url</code> <code>str</code> <p>The URL of the page to scrape for assets.</p> <code>allow_ext</code> <code>NotRequired[list[str]]</code> <p>Optional list of allowed file extensions.</p> <code>href_regex</code> <code>NotRequired[str]</code> <p>Optional regex pattern to match href attributes.</p> <code>limit</code> <code>NotRequired[int]</code> <p>Optional limit on number of assets to collect.</p> <code>base_url</code> <code>NotRequired[str]</code> <p>Optional base URL for relative links.</p> Source code in <code>src/civic_interconnect/paperkit/config.py</code> <pre><code>class PageAssetTD(TypedDict, total=False):\n    \"\"\"TypedDict for page-based asset configuration.\n\n    Attributes\n    ----------\n    page_url : str\n        The URL of the page to scrape for assets.\n    allow_ext : NotRequired[list[str]]\n        Optional list of allowed file extensions.\n    href_regex : NotRequired[str]\n        Optional regex pattern to match href attributes.\n    limit : NotRequired[int]\n        Optional limit on number of assets to collect.\n    base_url : NotRequired[str]\n        Optional base URL for relative links.\n    \"\"\"\n\n    page_url: str\n    allow_ext: NotRequired[list[str]]\n    href_regex: NotRequired[str]\n    limit: NotRequired[int]\n    base_url: NotRequired[str]\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.config.load_meta","title":"load_meta","text":"<pre><code>load_meta(meta_path: Path) -&gt; MetaTD\n</code></pre> <p>Load metadata from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>meta_path</code> <code>Path</code> <p>Path to the YAML metadata file.</p> required <p>Returns:</p> Type Description <code>MetaTD</code> <p>Dictionary containing the loaded and normalized metadata entries.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the YAML file does not contain a mapping of bibkeys.</p> Source code in <code>src/civic_interconnect/paperkit/config.py</code> <pre><code>def load_meta(meta_path: Path) -&gt; MetaTD:\n    \"\"\"Load metadata from a YAML file.\n\n    Parameters\n    ----------\n    meta_path : Path\n        Path to the YAML metadata file.\n\n    Returns\n    -------\n    MetaTD\n        Dictionary containing the loaded and normalized metadata entries.\n\n    Raises\n    ------\n    ValueError\n        If the YAML file does not contain a mapping of bibkeys.\n    \"\"\"\n    raw_text = meta_path.read_text(encoding=\"utf-8\")\n    loaded: Any = yaml.safe_load(raw_text)\n    if loaded is None:\n        data: MetaTD = {}\n    elif isinstance(loaded, dict):\n        data = cast(\"MetaTD\", loaded)\n    else:\n        raise ValueError(\"refs_meta.yaml must be a mapping of bibkeys\")\n\n    # Normalize each entry\n    for key, entry in list(data.items()):\n        data[key] = _normalize_entry(entry)\n\n    logger.info(\"Loaded meta for %d keys from %s\", len(data), meta_path)\n    return data\n</code></pre>"},{"location":"api/#bibliography","title":"Bibliography","text":""},{"location":"api/#civic_interconnect.paperkit.bib","title":"civic_interconnect.paperkit.bib","text":"<p>Bibliography handling utilities for the paper kit.</p> <p>This module provides functionality for loading and processing BibTeX files: - BibEntry: TypedDict for bibliography entries - BibDatabaseLike: Protocol for bibliography database objects - load_bib_keys: Function to extract citation keys from BibTeX files</p> <p>File: src/civic_interconnect/paperkit/bib.py</p>"},{"location":"api/#civic_interconnect.paperkit.bib.BibDatabaseLike","title":"BibDatabaseLike","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for bibliography database objects.</p> <p>This protocol defines the interface for bibliography database objects that contain a list of bibliography entries and support attribute access.</p> <p>Attributes:</p> Name Type Description <code>entries</code> <code>List[BibEntry]</code> <p>A list of bibliography entries from the database.</p> <p>Methods:</p> Name Description <code>__getattr__</code> <p>Provide access to additional attributes on the database object.</p> Source code in <code>src/civic_interconnect/paperkit/bib.py</code> <pre><code>class BibDatabaseLike(Protocol):\n    \"\"\"Protocol for bibliography database objects.\n\n    This protocol defines the interface for bibliography database objects\n    that contain a list of bibliography entries and support attribute access.\n\n    Attributes\n    ----------\n    entries : List[BibEntry]\n        A list of bibliography entries from the database.\n\n    Methods\n    -------\n    __getattr__(name: str) -&gt; object\n        Provide access to additional attributes on the database object.\n    \"\"\"\n\n    entries: list[BibEntry]\n\n    def __getattr__(self, name: str) -&gt; object:\n        \"\"\"Provide access to additional attributes on the database object.\"\"\"\n        ...\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.bib.BibDatabaseLike.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; object\n</code></pre> <p>Provide access to additional attributes on the database object.</p> Source code in <code>src/civic_interconnect/paperkit/bib.py</code> <pre><code>def __getattr__(self, name: str) -&gt; object:\n    \"\"\"Provide access to additional attributes on the database object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.bib.BibEntry","title":"BibEntry","text":"<p>               Bases: <code>TypedDict</code></p> <p>A bibliography entry from a BibTeX file.</p> <p>Attributes:</p> Name Type Description <code>ID</code> <code>str</code> <p>The citation key/identifier for the bibliography entry.</p> Source code in <code>src/civic_interconnect/paperkit/bib.py</code> <pre><code>class BibEntry(TypedDict, total=False):\n    \"\"\"A bibliography entry from a BibTeX file.\n\n    Attributes\n    ----------\n    ID : str\n        The citation key/identifier for the bibliography entry.\n    \"\"\"\n\n    ID: str\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.bib.load_bib_keys","title":"load_bib_keys","text":"<pre><code>load_bib_keys(bib_path: Path) -&gt; list[str]\n</code></pre> <p>Load citation keys from a BibTeX file.</p> Source code in <code>src/civic_interconnect/paperkit/bib.py</code> <pre><code>def load_bib_keys(bib_path: Path) -&gt; list[str]:\n    \"\"\"Load citation keys from a BibTeX file.\"\"\"\n    with bib_path.open(\"r\", encoding=\"utf-8\") as f:\n        db_raw: BibDatabaseLike = bibtexparser.load(f)  # type: ignore[assignment]\n\n    entries: list[BibEntry] = db_raw.entries\n    keys: list[str] = [e[\"ID\"] for e in entries if \"ID\" in e]\n\n    logger.debug(\"Loaded %d keys from %s\", len(keys), bib_path)\n    return keys\n</code></pre>"},{"location":"api/#orchestration","title":"Orchestration","text":""},{"location":"api/#civic_interconnect.paperkit.orchestrate","title":"civic_interconnect.paperkit.orchestrate","text":"<p>Orchestration module for downloading and managing assets linked to bibliography entries.</p> <p>This module provides: - DownloadRecord and Summary dataclasses for tracking downloads, - Functions to guess filenames, run the download process, and handle asset scraping.</p> <p>File: src/civic_interconnect/paperkit/orchestrate.py</p>"},{"location":"api/#civic_interconnect.paperkit.orchestrate.DownloadRecord","title":"DownloadRecord  <code>dataclass</code>","text":"<p>Represents a record of downloaded assets for a bibliography entry.</p> <p>Attributes:</p> Name Type Description <code>bibkey</code> <code>str</code> <p>The bibliography key associated with the entry.</p> <code>paths</code> <code>list[Path]</code> <p>List of file paths to successfully downloaded assets.</p> <code>errors</code> <code>list[str]</code> <p>List of error messages encountered during download.</p> Source code in <code>src/civic_interconnect/paperkit/orchestrate.py</code> <pre><code>@dataclass\nclass DownloadRecord:\n    \"\"\"Represents a record of downloaded assets for a bibliography entry.\n\n    Attributes\n    ----------\n    bibkey : str\n        The bibliography key associated with the entry.\n    paths : list[Path]\n        List of file paths to successfully downloaded assets.\n    errors : list[str]\n        List of error messages encountered during download.\n    \"\"\"\n\n    bibkey: str\n    paths: list[Path] = field(default_factory=lambda: [])\n    errors: list[str] = field(default_factory=lambda: [])\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.orchestrate.Summary","title":"Summary  <code>dataclass</code>","text":"<p>Summary of the download process for bibliography entries.</p> <p>Attributes:</p> Name Type Description <code>processed</code> <code>list[DownloadRecord]</code> <p>List of records for processed entries.</p> <code>skipped</code> <code>list[str]</code> <p>List of keys that were skipped.</p> Source code in <code>src/civic_interconnect/paperkit/orchestrate.py</code> <pre><code>@dataclass\nclass Summary:\n    \"\"\"Summary of the download process for bibliography entries.\n\n    Attributes\n    ----------\n    processed : list[DownloadRecord]\n        List of records for processed entries.\n    skipped : list[str]\n        List of keys that were skipped.\n    \"\"\"\n\n    processed: list[DownloadRecord] = field(default_factory=list)\n    skipped: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.orchestrate.guess_filename_from_url","title":"guess_filename_from_url","text":"<pre><code>guess_filename_from_url(url: str) -&gt; str\n</code></pre> <p>Guess a safe filename from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL from which to extract the filename.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A sanitized filename derived from the URL.</p> Source code in <code>src/civic_interconnect/paperkit/orchestrate.py</code> <pre><code>def guess_filename_from_url(url: str) -&gt; str:\n    \"\"\"Guess a safe filename from a URL.\n\n    Parameters\n    ----------\n    url : str\n        The URL from which to extract the filename.\n\n    Returns\n    -------\n    str\n        A sanitized filename derived from the URL.\n    \"\"\"\n    base = Path(urlparse(url).path).name or \"download\"\n    return safe_filename(base)\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.orchestrate.run","title":"run","text":"<pre><code>run(\n    bib_path: Path,\n    meta_path: Path,\n    out_root: Path,\n    client: Any,\n) -&gt; Summary\n</code></pre> <p>Orchestrate the download of assets for bibliography entries.</p> <p>Parameters:</p> Name Type Description Default <code>bib_path</code> <code>Path</code> <p>Path to the bibliography file.</p> required <code>meta_path</code> <code>Path</code> <p>Path to the metadata file.</p> required <code>out_root</code> <code>Path</code> <p>Root directory for output files.</p> required <code>client</code> <code>any</code> <p>HTTP client for downloading files.</p> required <p>Returns:</p> Type Description <code>Summary</code> <p>Summary of processed entries and any errors encountered.</p> Source code in <code>src/civic_interconnect/paperkit/orchestrate.py</code> <pre><code>def run(bib_path: Path, meta_path: Path, out_root: Path, client: Any) -&gt; Summary:\n    \"\"\"Orchestrate the download of assets for bibliography entries.\n\n    Parameters\n    ----------\n    bib_path : Path\n        Path to the bibliography file.\n    meta_path : Path\n        Path to the metadata file.\n    out_root : Path\n        Root directory for output files.\n    client : any\n        HTTP client for downloading files.\n\n    Returns\n    -------\n    Summary\n        Summary of processed entries and any errors encountered.\n    \"\"\"\n    keys = set(load_bib_keys(bib_path))\n    meta = load_meta(meta_path)\n    common = sorted(keys.intersection(meta.keys()))\n    summary = Summary()\n\n    if not common:\n        logger.warning(\"No overlapping keys between .bib and meta; nothing to do.\")\n        return summary\n\n    for key in common:\n        rec = DownloadRecord(bibkey=key)\n        entry_meta = meta[key] or {}\n        subdir = entry_meta.get(\"out_dir\")\n        assets = entry_meta.get(\"assets\", [])\n\n        for a in assets:\n            try:\n                # direct file\n                if \"url\" in a:\n                    out_dir = out_root / key / (subdir or \".\")\n                    ensure_dir(out_dir)\n                    fname = a.get(\"filename\") or guess_filename_from_url(a[\"url\"])\n                    p = out_dir / fname\n                    download_file(client, a[\"url\"], p, a.get(\"checksum\"))\n                    rec.paths.append(p)\n                # page scrape\n                elif \"page_url\" in a:\n                    logger.info(\"[%s] Scraping page %s\", key, a[\"page_url\"])\n                    allow = a.get(\"allow_ext\") or DEFAULT_ALLOWED_EXTS\n                    rx = a.get(\"href_regex\")\n                    limit = a.get(\"limit\")\n                    resp = client.get(a[\"page_url\"])\n                    links = extract_links(resp.text, a.get(\"base_url\") or a[\"page_url\"], allow, rx)\n                    if limit is not None:\n                        links = links[: int(limit)]\n                    out_dir = out_root / key / (subdir or \".\")\n                    ensure_dir(out_dir)\n                    for u in links:\n                        p = out_dir / guess_filename_from_url(u)\n                        download_file(client, u, p)\n                        rec.paths.append(p)\n                else:\n                    msg = \"unknown asset type\"\n                    rec.errors.append(msg)\n                    logger.warning(\"[%s] %s\", key, msg)\n            except Exception as exc:\n                rec.errors.append(str(exc))\n                logger.error(\"[%s] %s\", key, exc)\n        summary.processed.append(rec)\n    return summary\n</code></pre>"},{"location":"api/#http-client","title":"HTTP Client","text":""},{"location":"api/#civic_interconnect.paperkit.http_client","title":"civic_interconnect.paperkit.http_client","text":"<p>HTTP client wrapper for making GET requests with retries and logging.</p> <p>This module provides the HttpClient dataclass for robust HTTP GET requests, including configurable timeout, retries, backoff, and user-agent.</p> <p>File: src/civic_interconnect/paperkit/http_client.py</p>"},{"location":"api/#civic_interconnect.paperkit.http_client.HttpClient","title":"HttpClient  <code>dataclass</code>","text":"<p>HTTP client for making GET requests with retries, backoff, and custom user-agent.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>Session</code> <p>The requests session used for HTTP requests.</p> <code>timeout</code> <code>int</code> <p>Timeout for each request in seconds.</p> <code>retries</code> <code>int</code> <p>Number of retry attempts for failed requests.</p> <code>backoff_seconds</code> <code>int</code> <p>Base seconds to wait between retries (multiplied by attempt number).</p> <code>user_agent</code> <code>str</code> <p>User-Agent header for requests.</p> Source code in <code>src/civic_interconnect/paperkit/http_client.py</code> <pre><code>@dataclass\nclass HttpClient:\n    \"\"\"HTTP client for making GET requests with retries, backoff, and custom user-agent.\n\n    Attributes\n    ----------\n    session : requests.Session\n        The requests session used for HTTP requests.\n    timeout : int\n        Timeout for each request in seconds.\n    retries : int\n        Number of retry attempts for failed requests.\n    backoff_seconds : int\n        Base seconds to wait between retries (multiplied by attempt number).\n    user_agent : str\n        User-Agent header for requests.\n    \"\"\"\n\n    session: requests.Session\n    timeout: int = 30\n    retries: int = 3\n    backoff_seconds: int = 2\n    user_agent: str = \"ci-paper-fetcher/1.0\"\n\n    def get(self, url: str) -&gt; requests.Response:\n        \"\"\"Perform an HTTP GET request with retries and exponential backoff.\n\n        Parameters\n        ----------\n        url : str\n            The URL to send the GET request to.\n\n        Returns\n        -------\n        requests.Response\n            The HTTP response object.\n\n        Raises\n        ------\n        Exception\n            If all retry attempts fail, the last exception is raised.\n        \"\"\"\n        last_exc: Exception | None = None\n        headers = {\"User-Agent\": self.user_agent}\n        for attempt in range(1, self.retries + 1):\n            try:\n                logger.debug(\"HTTP GET %s (attempt %s)\", url, attempt)\n                resp = self.session.get(url, timeout=self.timeout, headers=headers)\n                resp.raise_for_status()\n                return resp\n            except Exception as exc:\n                logger.warning(\"HTTP GET failed for %s on attempt %s: %s\", url, attempt, exc)\n                last_exc = exc\n                if attempt &lt; self.retries:\n                    time.sleep(self.backoff_seconds * attempt)\n        logger.error(\"HTTP GET giving up for %s\", url)\n        raise last_exc if last_exc else RuntimeError(\"HTTP get failed unexpectedly\")\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.http_client.HttpClient.get","title":"get","text":"<pre><code>get(url: str) -&gt; requests.Response\n</code></pre> <p>Perform an HTTP GET request with retries and exponential backoff.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the GET request to.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>The HTTP response object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If all retry attempts fail, the last exception is raised.</p> Source code in <code>src/civic_interconnect/paperkit/http_client.py</code> <pre><code>def get(self, url: str) -&gt; requests.Response:\n    \"\"\"Perform an HTTP GET request with retries and exponential backoff.\n\n    Parameters\n    ----------\n    url : str\n        The URL to send the GET request to.\n\n    Returns\n    -------\n    requests.Response\n        The HTTP response object.\n\n    Raises\n    ------\n    Exception\n        If all retry attempts fail, the last exception is raised.\n    \"\"\"\n    last_exc: Exception | None = None\n    headers = {\"User-Agent\": self.user_agent}\n    for attempt in range(1, self.retries + 1):\n        try:\n            logger.debug(\"HTTP GET %s (attempt %s)\", url, attempt)\n            resp = self.session.get(url, timeout=self.timeout, headers=headers)\n            resp.raise_for_status()\n            return resp\n        except Exception as exc:\n            logger.warning(\"HTTP GET failed for %s on attempt %s: %s\", url, attempt, exc)\n            last_exc = exc\n            if attempt &lt; self.retries:\n                time.sleep(self.backoff_seconds * attempt)\n    logger.error(\"HTTP GET giving up for %s\", url)\n    raise last_exc if last_exc else RuntimeError(\"HTTP get failed unexpectedly\")\n</code></pre>"},{"location":"api/#download","title":"Download","text":""},{"location":"api/#civic_interconnect.paperkit.download","title":"civic_interconnect.paperkit.download","text":"<p>File download utilities with checksum validation and safe filename handling.</p> <p>This module provides: - ensure_dir: Create directories recursively if they don't exist - safe_filename: Convert strings to filesystem-safe filenames - sha256_file: Calculate SHA256 hash of a file - write_bytes: Write bytes to a file with directory creation - download_file: Download files with optional checksum verification</p> <p>File: src/civic_interconnect/paperkit/download.py</p>"},{"location":"api/#civic_interconnect.paperkit.download.download_file","title":"download_file","text":"<pre><code>download_file(\n    client: Any,\n    url: str,\n    out_path: Path,\n    checksum: str | None = None,\n) -&gt; Path\n</code></pre> <p>Download a file from a URL, save it to a path, and optionally verify its checksum.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Any</code> <p>HTTP client with a .get(url) method returning a response with .content.</p> required <code>url</code> <code>str</code> <p>The URL to download the file from.</p> required <code>out_path</code> <code>Path</code> <p>The path to save the downloaded file.</p> required <code>checksum</code> <code>str | None</code> <p>Optional SHA256 checksum to verify the downloaded file.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the saved file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the checksum does not match.</p> Source code in <code>src/civic_interconnect/paperkit/download.py</code> <pre><code>def download_file(client: Any, url: str, out_path: Path, checksum: str | None = None) -&gt; Path:\n    \"\"\"Download a file from a URL, save it to a path, and optionally verify its checksum.\n\n    Parameters\n    ----------\n    client : Any\n        HTTP client with a .get(url) method returning a response with .content.\n    url : str\n        The URL to download the file from.\n    out_path : Path\n        The path to save the downloaded file.\n    checksum : str | None, optional\n        Optional SHA256 checksum to verify the downloaded file.\n\n    Returns\n    -------\n    Path\n        The path to the saved file.\n\n    Raises\n    ------\n    ValueError\n        If the checksum does not match.\n    \"\"\"\n    logger.info(\"Downloading %s -&gt; %s\", url, out_path)\n    resp = client.get(url)\n    write_bytes(out_path, resp.content)\n    if checksum:\n        actual = sha256_file(out_path)\n        if actual.lower() != checksum.lower():\n            logger.error(\"Checksum mismatch for %s\", out_path)\n            raise ValueError(f\"checksum mismatch for {out_path}\")\n    return out_path\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.download.ensure_dir","title":"ensure_dir","text":"<pre><code>ensure_dir(p: Path) -&gt; None\n</code></pre> <p>Create the directory at the given path, including any necessary parent directories.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Path</code> <p>The directory path to create.</p> required Source code in <code>src/civic_interconnect/paperkit/download.py</code> <pre><code>def ensure_dir(p: Path) -&gt; None:\n    \"\"\"Create the directory at the given path, including any necessary parent directories.\n\n    Parameters\n    ----------\n    p : Path\n        The directory path to create.\n    \"\"\"\n    p.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.download.safe_filename","title":"safe_filename","text":"<pre><code>safe_filename(name: str) -&gt; str\n</code></pre> <p>Convert a string to a filesystem-safe filename.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The original filename or string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A sanitized, filesystem-safe filename.</p> Source code in <code>src/civic_interconnect/paperkit/download.py</code> <pre><code>def safe_filename(name: str) -&gt; str:\n    \"\"\"Convert a string to a filesystem-safe filename.\n\n    Parameters\n    ----------\n    name : str\n        The original filename or string.\n\n    Returns\n    -------\n    str\n        A sanitized, filesystem-safe filename.\n    \"\"\"\n    name = unescape(name).strip()\n    name = re.sub(r\"[\\\\/:*?\\\"&lt;&gt;|\\s]+\", \"_\", name)\n    name = name.encode(\"ascii\", \"ignore\").decode(\"ascii\")\n    name = re.sub(r\"_+\", \"_\", name).strip(\"_\")\n    return name or \"file\"\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.download.sha256_file","title":"sha256_file","text":"<pre><code>sha256_file(path: Path) -&gt; str\n</code></pre> <p>Calculate the SHA256 hash of a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the file to hash.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SHA256 hexadecimal digest of the file.</p> Source code in <code>src/civic_interconnect/paperkit/download.py</code> <pre><code>def sha256_file(path: Path) -&gt; str:\n    \"\"\"Calculate the SHA256 hash of a file.\n\n    Parameters\n    ----------\n    path : Path\n        The path to the file to hash.\n\n    Returns\n    -------\n    str\n        The SHA256 hexadecimal digest of the file.\n    \"\"\"\n    h = hashlib.sha256()\n    with path.open(\"rb\") as f:\n        for chunk in iter(lambda: f.read(1024 * 1024), b\"\"):\n            h.update(chunk)\n    return h.hexdigest()\n</code></pre>"},{"location":"api/#civic_interconnect.paperkit.download.write_bytes","title":"write_bytes","text":"<pre><code>write_bytes(path: Path, content: bytes) -&gt; None\n</code></pre> <p>Write bytes to a file, creating parent directories if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The file path to write to.</p> required <code>content</code> <code>bytes</code> <p>The bytes content to write.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/civic_interconnect/paperkit/download.py</code> <pre><code>def write_bytes(path: Path, content: bytes) -&gt; None:\n    \"\"\"Write bytes to a file, creating parent directories if necessary.\n\n    Parameters\n    ----------\n    path : Path\n        The file path to write to.\n    content : bytes\n        The bytes content to write.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    ensure_dir(path.parent)\n    with path.open(\"wb\") as f:\n        f.write(content)\n    logger.info(\"Saved %s\", path)\n</code></pre>"},{"location":"api/#web-scraping","title":"Web Scraping","text":""},{"location":"api/#civic_interconnect.paperkit.scrape","title":"civic_interconnect.paperkit.scrape","text":"<p>Functions for extracting and filtering links from HTML documents.</p> <p>This module provides utilities to parse HTML, extract anchor links, filter them by extension and regular expression, and log the results.</p> <p>File: src/civic_interconnect/paperkit/scrape.py</p>"},{"location":"api/#civic_interconnect.paperkit.scrape.extract_links","title":"extract_links","text":"<pre><code>extract_links(\n    html: str,\n    base_url: str,\n    allow_ext: list[str],\n    href_regex: str | None,\n) -&gt; list[str]\n</code></pre> <p>Extract and filter anchor links from an HTML document.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML content to parse.</p> required <code>base_url</code> <code>str</code> <p>The base URL to resolve relative links.</p> required <code>allow_ext</code> <code>list[str]</code> <p>List of allowed file extensions (e.g., ['.pdf', '.html']).</p> required <code>href_regex</code> <code>str | None</code> <p>Optional regular expression to further filter hrefs.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of filtered, absolute URLs extracted from the HTML.</p> Source code in <code>src/civic_interconnect/paperkit/scrape.py</code> <pre><code>def extract_links(\n    html: str, base_url: str, allow_ext: list[str], href_regex: str | None\n) -&gt; list[str]:\n    \"\"\"Extract and filter anchor links from an HTML document.\n\n    Parameters\n    ----------\n    html : str\n        The HTML content to parse.\n    base_url : str\n        The base URL to resolve relative links.\n    allow_ext : list[str]\n        List of allowed file extensions (e.g., ['.pdf', '.html']).\n    href_regex : str | None\n        Optional regular expression to further filter hrefs.\n\n    Returns\n    -------\n    list[str]\n        List of filtered, absolute URLs extracted from the HTML.\n    \"\"\"\n    soup = BeautifulSoup(html, \"html.parser\")\n    rx = re.compile(href_regex, re.I) if href_regex else None\n    out: list[str] = []\n    seen: set[str] = set()\n\n    allow = [e.lower() for e in allow_ext] if allow_ext else []\n\n    for a in soup.find_all(\"a\", href=True):\n        href = str(a[\"href\"]).strip()\n        full = urljoin(base_url, href)\n        ext = Path(urlparse(full).path).suffix.lower()\n        if allow and ext not in allow:\n            continue\n        if rx and not rx.search(href):\n            continue\n        if full not in seen:\n            seen.add(full)\n            out.append(full)\n    logger.debug(\"Extracted %d links from %s\", len(out), base_url)\n    return out\n</code></pre>"},{"location":"api/#cli","title":"CLI","text":""},{"location":"api/#civic_interconnect.paperkit.cli","title":"civic_interconnect.paperkit.cli","text":"<p>Command-line interface for the paperkit tool.</p> <p>This module provides the main CLI entry point for fetching public data for bibliography references, including argument parsing and orchestration of the fetch process.</p> <p>File: src/civic_interconnect/paperkit/cli.py</p>"},{"location":"api/#civic_interconnect.paperkit.cli.main","title":"main","text":"<pre><code>main() -&gt; int\n</code></pre> <p>Run the paperkit CLI.</p> Source code in <code>src/civic_interconnect/paperkit/cli.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Run the paperkit CLI.\"\"\"\n    ap = argparse.ArgumentParser(description=\"Fetch public data for .bib references\")\n    ap.add_argument(\"--bib\", type=Path, default=Path(\"paper/refs.bib\"))\n    ap.add_argument(\"--meta\", type=Path, default=Path(\"paper/refs_meta.yaml\"))\n    ap.add_argument(\"--out\", type=Path, default=DEFAULT_OUTPUT_ROOT)\n    ap.add_argument(\"--log-level\", type=str, default=\"INFO\", help=\"DEBUG, INFO, WARNING, ERROR\")\n    args = ap.parse_args()\n\n    configure(args.log_level)\n    logger.info(\"Starting paperkit fetch with bib=%s meta=%s out=%s\", args.bib, args.meta, args.out)\n\n    client: HttpClient = HttpClient(session=requests.Session())\n    summary = run(args.bib, args.meta, args.out, client)\n\n    for rec in summary.processed:\n        for p in rec.paths:\n            logger.info(\"[%s] saved %s\", rec.bibkey, p)\n        for e in rec.errors:\n            logger.error(\"[%s] ERROR %s\", rec.bibkey, e)\n    return 0\n</code></pre>"},{"location":"api/#logging","title":"Logging","text":""},{"location":"api/#civic_interconnect.paperkit.log","title":"civic_interconnect.paperkit.log","text":"<p>Logging utilities for the civic_interconnect.paperkit module.</p> <p>Provides a library-wide logger and optional configuration for console output.</p> <p>File: src/civic_interconnect/paperkit/log.py</p>"},{"location":"api/#civic_interconnect.paperkit.log.configure","title":"configure","text":"<pre><code>configure(level: str = 'INFO') -&gt; None\n</code></pre> <p>Configure basic console output for logging.</p> <p>Only used by the CLI or by applications that explicitly opt in.</p> Source code in <code>src/civic_interconnect/paperkit/log.py</code> <pre><code>def configure(level: str = \"INFO\") -&gt; None:\n    \"\"\"Configure basic console output for logging.\n\n    Only used by the CLI or by applications that explicitly opt in.\n    \"\"\"\n    level = level.upper()\n    # If root already has handlers, do not reconfigure.\n    if logging.getLogger().handlers:\n        logging.getLogger().setLevel(getattr(logging, level, logging.INFO))\n        return\n\n    fmt = \"%(asctime)s | %(levelname)-7s | %(name)s | %(message)s\"\n    logging.basicConfig(level=getattr(logging, level, logging.INFO), format=fmt)\n</code></pre>"}]}